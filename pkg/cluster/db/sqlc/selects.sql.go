// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: selects.sql

package sqlc

import (
	"context"
	"database/sql"
)

const checkClusterExistsWithData = `-- name: CheckClusterExistsWithData :one
SELECT
    cluster_id,
    name,
    description
FROM
    clusters
WHERE
    name = ?
LIMIT
    1
`

func (q *Queries) CheckClusterExistsWithData(ctx context.Context, name string) (Cluster, error) {
	row := q.db.QueryRowContext(ctx, checkClusterExistsWithData, name)
	var i Cluster
	err := row.Scan(&i.ClusterID, &i.Name, &i.Description)
	return i, err
}

const checkIfClassExists = `-- name: CheckIfClassExists :one
SELECT
    EXISTS(
        SELECT
            1
        FROM
            classes
        WHERE
            cluster_id = ?
            AND name = ?
        LIMIT
            1
    )
`

type CheckIfClassExistsParams struct {
	ClusterID int64
	Name      string
}

func (q *Queries) CheckIfClassExists(ctx context.Context, arg CheckIfClassExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkIfClassExists, arg.ClusterID, arg.Name)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const checkIfClusterExists = `-- name: CheckIfClusterExists :one
SELECT
    EXISTS(
        SELECT
            1
        FROM
            clusters
        WHERE
            name = ?
        LIMIT
            1
    )
`

func (q *Queries) CheckIfClusterExists(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkIfClusterExists, name)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const checkIfNodeExists = `-- name: CheckIfNodeExists :one
SELECT
    EXISTS(
        SELECT
            1
        FROM
            nodes
        WHERE
            cluster_id = ?
            AND host = ?
            AND port = ?
        LIMIT
            1
    )
`

type CheckIfNodeExistsParams struct {
	ClusterID int64
	Host      string
	Port      int64
}

func (q *Queries) CheckIfNodeExists(ctx context.Context, arg CheckIfNodeExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkIfNodeExists, arg.ClusterID, arg.Host, arg.Port)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getAllExerciseNameFromCluster = `-- name: GetAllExerciseNameFromCluster :many
SELECT
    DISTINCT(e.name)
FROM
    exercises e
    JOIN group_assignments ga ON e.group_id = ga.group_id
    JOIN groups g ON e.group_id = g.group_id
    JOIN classes c ON g.class_id = c.class_id
    JOIN clusters ca ON c.cluster_id = ca.cluster_id
WHERE
    ca.name = ?
`

func (q *Queries) GetAllExerciseNameFromCluster(ctx context.Context, name string) ([]interface{}, error) {
	rows, err := q.db.QueryContext(ctx, getAllExerciseNameFromCluster, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var column_1 interface{}
		if err := rows.Scan(&column_1); err != nil {
			return nil, err
		}
		items = append(items, column_1)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassDisribution = `-- name: GetClassDisribution :many
SELECT
    c.name AS class_name,
    c.description AS class_desc,
    n.protocol || '://' || n.host || ':' || CAST(n.port AS TEXT) AS node_url,
    g.name AS group_name,
    u.username AS username
FROM
    classes c
    JOIN groups g ON g.class_id = c.class_id
    JOIN users u ON u.group_id = g.group_id
    JOIN group_assignments ga ON ga.group_id = g.group_id
    JOIN nodes n ON n.node_id = ga.node_id
WHERE
    c.cluster_id = ?
ORDER BY
    c.name,
    n.node_id,
    g.group_id,
    u.user_id
`

type GetClassDisributionRow struct {
	ClassName string
	ClassDesc sql.NullString
	NodeUrl   interface{}
	GroupName string
	Username  string
}

func (q *Queries) GetClassDisribution(ctx context.Context, clusterID int64) ([]GetClassDisributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getClassDisribution, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClassDisributionRow
	for rows.Next() {
		var i GetClassDisributionRow
		if err := rows.Scan(
			&i.ClassName,
			&i.ClassDesc,
			&i.NodeUrl,
			&i.GroupName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClasses = `-- name: GetClasses :many
SELECT
    class_id,
    cluster_id,
    name,
    description
FROM
    classes
WHERE
    cluster_id = ?
ORDER BY
    name
`

func (q *Queries) GetClasses(ctx context.Context, clusterID int64) ([]Class, error) {
	rows, err := q.db.QueryContext(ctx, getClasses, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Class
	for rows.Next() {
		var i Class
		if err := rows.Scan(
			&i.ClassID,
			&i.ClusterID,
			&i.Name,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClusterByID = `-- name: GetClusterByID :one
SELECT
    cluster_id,
    name,
    description
FROM
    clusters
WHERE
    name = ?
LIMIT
    1
`

func (q *Queries) GetClusterByID(ctx context.Context, name string) (Cluster, error) {
	row := q.db.QueryRowContext(ctx, getClusterByID, name)
	var i Cluster
	err := row.Scan(&i.ClusterID, &i.Name, &i.Description)
	return i, err
}

const getClusters = `-- name: GetClusters :many
SELECT
    cluster_id,
    name,
    description
FROM
    clusters
ORDER BY
    cluster_id
`

func (q *Queries) GetClusters(ctx context.Context) ([]Cluster, error) {
	rows, err := q.db.QueryContext(ctx, getClusters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cluster
	for rows.Next() {
		var i Cluster
		if err := rows.Scan(&i.ClusterID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesForDeletion = `-- name: GetExercisesForDeletion :many
SELECT
    e.project_uuid,
    e.name,
    c.name AS class_name,
    g.name AS group_name
FROM
    exercises e
    JOIN groups g ON e.group_id = g.group_id
    JOIN classes c ON g.class_id = c.class_id
WHERE
    e.name = ?
    AND (
        ? = ''
        OR c.name = ?
    )
    AND (
        ? = ''
        OR g.name = ?
    )
`

type GetExercisesForDeletionParams struct {
	Name    string
	Column2 interface{}
	Name_2  string
	Column4 interface{}
	Name_3  string
}

type GetExercisesForDeletionRow struct {
	ProjectUuid string
	Name        string
	ClassName   string
	GroupName   string
}

func (q *Queries) GetExercisesForDeletion(ctx context.Context, arg GetExercisesForDeletionParams) ([]GetExercisesForDeletionRow, error) {
	rows, err := q.db.QueryContext(ctx, getExercisesForDeletion,
		arg.Name,
		arg.Column2,
		arg.Name_2,
		arg.Column4,
		arg.Name_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExercisesForDeletionRow
	for rows.Next() {
		var i GetExercisesForDeletionRow
		if err := rows.Scan(
			&i.ProjectUuid,
			&i.Name,
			&i.ClassName,
			&i.GroupName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeExercisesForCluster = `-- name: GetNodeExercisesForCluster :many
SELECT
    n.protocol || '://' || n.host || ':' || CAST(n.port AS TEXT) AS node_url,
    e.name AS exercise_name,
    e.project_uuid,
    g.name AS group_name,
    e.state,
    c.class_id,
    c.name
FROM
    classes c
    JOIN groups g ON g.class_id = c.class_id
    JOIN exercises e ON e.group_id = g.group_id
    JOIN group_assignments ga ON ga.group_id = g.group_id
    JOIN nodes n ON n.node_id = ga.node_id
WHERE
    c.cluster_id = ?
    AND e.state <> 'deleted'
ORDER BY
    n.node_id,
    g.group_id,
    e.exercise_id
`

type GetNodeExercisesForClusterRow struct {
	NodeUrl      interface{}
	ExerciseName string
	ProjectUuid  string
	GroupName    string
	State        sql.NullString
	ClassID      int64
	Name         string
}

func (q *Queries) GetNodeExercisesForCluster(ctx context.Context, clusterID int64) ([]GetNodeExercisesForClusterRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeExercisesForCluster, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeExercisesForClusterRow
	for rows.Next() {
		var i GetNodeExercisesForClusterRow
		if err := rows.Scan(
			&i.NodeUrl,
			&i.ExerciseName,
			&i.ProjectUuid,
			&i.GroupName,
			&i.State,
			&i.ClassID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeGroupAssignments = `-- name: GetNodeGroupAssignments :many
SELECT
    ga.node_id,
    COUNT(*)
FROM
    group_assignments ga
    JOIN nodes n ON n.node_id = ga.node_id
WHERE
    n.cluster_id = ?
GROUP BY
    ga.node_id
`

type GetNodeGroupAssignmentsRow struct {
	NodeID int64
	Count  int64
}

func (q *Queries) GetNodeGroupAssignments(ctx context.Context, clusterID int64) ([]GetNodeGroupAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeGroupAssignments, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeGroupAssignmentsRow
	for rows.Next() {
		var i GetNodeGroupAssignmentsRow
		if err := rows.Scan(&i.NodeID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeGroupNamesForClass = `-- name: GetNodeGroupNamesForClass :many
SELECT
    n.protocol || '://' || n.host || ':' || CAST(n.port AS TEXT) AS node_url,
    g.name AS group_name,
    u.username,
    u.full_name,
    u.default_password
FROM
    classes c
    JOIN groups g ON g.class_id = c.class_id
    JOIN users u ON u.group_id = g.group_id
    JOIN group_assignments ga ON ga.group_id = g.group_id
    JOIN nodes n ON n.node_id = ga.node_id
WHERE
    c.cluster_id = ?
    AND c.name = ?
ORDER BY
    n.node_id,
    g.group_id,
    u.user_id
`

type GetNodeGroupNamesForClassParams struct {
	ClusterID int64
	Name      string
}

type GetNodeGroupNamesForClassRow struct {
	NodeUrl         interface{}
	GroupName       string
	Username        string
	FullName        sql.NullString
	DefaultPassword string
}

func (q *Queries) GetNodeGroupNamesForClass(ctx context.Context, arg GetNodeGroupNamesForClassParams) ([]GetNodeGroupNamesForClassRow, error) {
	rows, err := q.db.QueryContext(ctx, getNodeGroupNamesForClass, arg.ClusterID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNodeGroupNamesForClassRow
	for rows.Next() {
		var i GetNodeGroupNamesForClassRow
		if err := rows.Scan(
			&i.NodeUrl,
			&i.GroupName,
			&i.Username,
			&i.FullName,
			&i.DefaultPassword,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodes = `-- name: GetNodes :many
SELECT
    node_id,
    cluster_id,
    protocol,
    auth_user,
    host,
    port,
    weight,
    max_groups
FROM
    nodes
ORDER BY
    cluster_id
`

func (q *Queries) GetNodes(ctx context.Context) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.NodeID,
			&i.ClusterID,
			&i.Protocol,
			&i.AuthUser,
			&i.Host,
			&i.Port,
			&i.Weight,
			&i.MaxGroups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodesFromClusterID = `-- name: GetNodesFromClusterID :many
SELECT
    node_id,
    cluster_id,
    protocol,
    auth_user,
    host,
    port,
    weight,
    max_groups
FROM
    nodes
WHERE
    cluster_id = ?
`

func (q *Queries) GetNodesFromClusterID(ctx context.Context, clusterID int64) ([]Node, error) {
	rows, err := q.db.QueryContext(ctx, getNodesFromClusterID, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.NodeID,
			&i.ClusterID,
			&i.Protocol,
			&i.AuthUser,
			&i.Host,
			&i.Port,
			&i.Weight,
			&i.MaxGroups,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
